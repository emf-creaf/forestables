---
title: "Inventory data output"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Inventory data output}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
eval_code <- TRUE
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = eval_code
)
```

## Inventories outputs

`forestables` tries to uniformize, when possible, the outputs of different inventories. This makes
easier to design workflows that work with different inventories. This vignette shows and explains
the `forestables` output tibble.

### Example objects

`forestables` ships with some output examples:

```{r example_objects}
# load the library
library(forestables)

# fia example
fia_output_example

# ffi example
ffi_output_example

# ifn example
ifn_output_example
```

We are going to use these examples to explain the estructure of the output.

### Output estructure

Inventories outputs are dataframes (tibbles) in which each row is a plot/year combination
(plot/version in the IFN). Metadata for the plot is presented in the first columns (plot IDs,
coordinates info, topography...). The last three columns are always nested columns with the
`tree` table for that plot/year, `understory` table for that plot/year and `regen` table for that
plot/year.

![]("inventory_row.svg")

  * Common metadata among different inventories:  
    `id_unique_code`, `year`, `plot`, `coordx`, `coordy`, `coord_sys`, `crs`, `elev`, `aspect`,
    `slope`, `country`.
  
  * FIA unique metadata:  
    `state_code`, `state_ab`, `state_name`, `county_code`, `p3panel`, `p2veg_sampling_status_cd`,
    `p2veg_sampling_level_detail`, `rscd`, `design_code`, `subplot`.
  
  * IFN unique metadata:  
    `version`, `class`, `subclass`, `province_code`, `province_name_original`, `ca_name_original`,
    `sheet_ntm`, `huso`, `slope_mean`, `type`.
  
  * FFI unique metadata:  
    `dep`, `dep_name`, `visite`.
  
  * Nested columns common to all inventories:  
    `tree`, `understory`, `regen`

To know more about each variable, you can check the ????? vignette.

### Post-processing outputs

  1. **Cleaning empty data**. By default, `ifn_`, `fia_` and `ffi_to_tibble` functions return all
     plots requested, even if they don't have data for that year or version. The `clean_empty()`
     function can be used after retrieving the data to remove empty plots in `tree`, `shrub`,
     `herbs` and/or `regen` columns:

```{r clean_empty}
# FIA plots in AK for the 2015-2018 period
nrow(fia_output_example)
# FIA plots in AK for the 2015-2018 period with tree data
nrow(clean_empty(fia_output_example, c("tree")))
# FIA plots in AK for the 2015-2018 period with tree AND shrub AND herbs AND regen data
nrow(clean_empty(fia_output_example, c("tree", "shrub", "herbs", "regen")))
```

  2. **Transforming to spatial object**. By default, `ifn_`, `fia_` and `ffi_to_tibble` functions
     all return a tibble (data frame). These tibbles have the spatial information to be able to
     convert plots to spatial points. But this conversion is not straightforward as sometimes plots
     from the same inventory have different coordinate systems or projections. To do this
     `inventory_to_sf()` function can be used directly and it will make the necessary coordinate
     transformations to return plots as points in latitude-longitude format (CRS = 4326):

```{r inventory_as_sf}
ifn_output_example |>
  clean_empty("tree") |>
  inventory_as_sf()
```

### `tree` column

`tree` is a *nested column*, meaning that each cell contain the tree data table for that row
(i.e. the tree data table for that plot that year/version). As with the plot metadata, an effort to
uniformize the data between inventories has been done.

  * Common tree variables among different inventories:  
    `tree`, `sp_code`, `sp_name`, `status`, `density_factor`, `dia`, `height`.
  
  * IFN unique tree variables:  
    `tree_ifn2`, `tree_ifn3`, `tree_ifn4` `cubing_form`, `quality_wood`. Also, IFN lack the `status`
    variable.
  
  * FFI unique tree variables:  
    `height_last_recorded`, `status5`, `espar`.

The easiest way to access the tree data is with `unnest()`:

```{r tree_unnest}
fia_output_example |>
  clean_empty("tree") |>
  unnest("tree", names_sep = "_")
```


```{r tree_column, eval=FALSE, echo=FALSE}
ffi_tree_names <- ffi_output_example |>
  clean_empty("tree") |>
  dplyr::pull("tree") |>
  purrr::list_rbind() |>
  names()

ifn_tree_names <- ifn_output_example |>
  clean_empty("tree") |>
  dplyr::pull("tree") |>
  purrr::list_rbind() |>
  names()

fia_tree_names <- fia_output_example |>
  clean_empty("tree") |>
  dplyr::pull("tree") |>
  purrr::list_rbind() |>
  names()

all_tree_names <- c(ifn_tree_names, ffi_tree_names, fia_tree_names) |>
  unique()

common_tree_names <- c(ifn_tree_names, ffi_tree_names, fia_tree_names) |>
  magrittr::extract(
    c(ifn_tree_names, ffi_tree_names, fia_tree_names) |> duplicated() |> which()
  ) |>
  unique()

ifn_unique_names <- ifn_tree_names |>
  magrittr::extract(! ifn_tree_names %in% common_tree_names)
fia_unique_names <- fia_tree_names |>
  magrittr::extract(! fia_tree_names %in% common_tree_names)
ffi_unique_names <- ffi_tree_names |>
  magrittr::extract(! ffi_tree_names %in% common_tree_names)
```

### `understory` column

`understory` is also a *nested* column. It contains the data tables for shrubs and for herbs if
found in the inventory plot.

  * Common understory variables among different inventories:  
    `shrub`, `herbs`. Both are also nested columns, as each kindo of understory has different data
    estructure.
  
  * FFI unique understory variables:  
    `lign1_pct`, `lign2_pct`.

#### `shrub` column

  * Common shrub variables among different inventories:  
    `sp_code`, `sp_name`, `cover`, `height`, `growth_form`
  
  * FIA unique shrub variables:  
    `subplot`, `growth_form_code`.

#### `herbs` column

The `herbs` data is different in each inventory, and is not present in the IFN.

  * FIA unique herbs variables:  
    `subplot`, `sp_name`, `growth_form_code`, `height`, `cover`, `growth_form`, `sp_code`
  
  * FFI unique herbs variables:  
    `herb_pct`

The easiest way to access the understory data is with `unnest()`:

```{r understory_unnest}
ffi_output_example |>
  clean_empty("shrub") |>
  unnest("understory") |>
  unnest("shrub", names_sep = "_")

ffi_output_example |>
  clean_empty("herbs") |>
  unnest("understory") |>
  unnest("herbs", names_sep = "_")
```

```{r understory_column, eval=FALSE, echo=FALSE}
ffi_understory_names <- ffi_output_example |>
  clean_empty("herbs") |>
  dplyr::pull("understory") |>
  purrr::map("herbs") |>
  purrr::flatten() |>
  purrr::list_rbind() |>
  names()

ifn_understory_names <- ifn_output_example |>
  clean_empty("herbs") |>
  dplyr::pull("understory") |>
  purrr::map("herbs") |>
  purrr::flatten() |>
  purrr::list_rbind() |>
  names()

fia_understory_names <- fia_output_example |>
  clean_empty("herbs") |>
  dplyr::pull("understory") |>
  purrr::map("herbs") |>
  purrr::flatten() |>
  purrr::list_rbind() |>
  names()

all_understory_names <- c(ifn_understory_names, ffi_understory_names, fia_understory_names) |>
  unique()

common_understory_names <- c(ifn_understory_names, ffi_understory_names, fia_understory_names) |>
  magrittr::extract(
    c(ifn_understory_names, ffi_understory_names, fia_understory_names) |> duplicated() |> which()
  ) |>
  unique()

ifn_unique_names <- ifn_understory_names |>
  magrittr::extract(! ifn_understory_names %in% common_understory_names)
fia_unique_names <- fia_understory_names |>
  magrittr::extract(! fia_understory_names %in% common_understory_names)
ffi_unique_names <- ffi_understory_names |>
  magrittr::extract(! ffi_understory_names %in% common_understory_names)
```

### `regen` column

`regen` is a *nested column*, meaning that each cell contain the regen data table for that row
(i.e. the regen data table for that plot that year/version). As with the plot metadata, an effort to
uniformize the data between inventories has been done.

  * Common regen variables among different inventories:  
    `sp_code`, `sp_name`, `density_factor`, `dbh`, `height`, `n`.
  
  * FIA unique regen variables:  
    `subplot`, `treecount_calc`.
  
  * FFI unique regen variables:  
    `cover`, `growth_form`

The easiest way to access the regen data is with `unnest()`:

```{r regen_unnest}
ifn_output_example |>
  clean_empty("regen") |>
  unnest("regen", names_sep = "_")
```


```{r regen_column, eval=FALSE, echo=FALSE}
ffi_regen_names <- ffi_output_example |>
  clean_empty("regen") |>
  dplyr::pull("regen") |>
  purrr::list_rbind() |>
  names()

ifn_regen_names <- ifn_output_example |>
  clean_empty("regen") |>
  dplyr::pull("regen") |>
  purrr::list_rbind() |>
  names()

fia_regen_names <- fia_output_example |>
  clean_empty("regen") |>
  dplyr::pull("regen") |>
  purrr::list_rbind() |>
  names()

all_regen_names <- c(ifn_regen_names, ffi_regen_names, fia_regen_names) |>
  unique()

common_regen_names <- c(ifn_regen_names, ffi_regen_names, fia_regen_names) |>
  magrittr::extract(
    c(ifn_regen_names, ffi_regen_names, fia_regen_names) |> duplicated() |> which()
  ) |>
  unique()

ifn_unique_names <- ifn_regen_names |>
  magrittr::extract(! ifn_regen_names %in% common_regen_names)
fia_unique_names <- fia_regen_names |>
  magrittr::extract(! fia_regen_names %in% common_regen_names)
ffi_unique_names <- ffi_regen_names |>
  magrittr::extract(! ffi_regen_names %in% common_regen_names)
```